#22.5 list 표현식 사용하기 

#파이썬에서는 리스트 안에 for 반복문과 if 조건문을 사용할 수 있다 -> list comprehension표현식: 리스트 안에 식, for 반복문, if 조건문 등을 지정하여 리스트를 생성하는 것
    
    # 리스트 내포, 리스트 내장, 리스트 축약, 리스트 해석, ... 등으로 불린다


#아래와 같이 []안에 만들 수도 있고 list()로 만들 수도 있다
    # [식 for 변수 in 리스트]       -> python style, preferred
    # list(식 for 변수 in 리스트)   -> C style
    # 2가지 방법 중 대괄호 방식 [] 이 더 성능이 좋음  

a = [i for i in range(10)]  # 0부터 9까지 숫자를 생성하여 리스트 생성
print(a, len(a))    #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 10

b = list(i for i in range(10))  # 0부터 9까지 숫자를 생성하여 리스트 생성
print(b, len(b))    #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 10


#응용   
c = [i+5 for i in range(10)]
print(c, len(c))    #[5, 6, 7, 8, 9, 10, 11, 12, 13, 14] 10

d = [i*2 for i in range(5)]
print(d, len(d))    #[0, 2, 4, 6, 8] 5



#list comprehension 에서 if 조건문 사용하기 
    # [식 for 변수 in 리스트 if 조건식]
    # list(식 for 변수 in 리스트 if 조건식)

a = [i for i in range(10) if i%2 == 0]  # 0~9 숫자 중 2의 배수인 숫자(짝수)로 리스트 생성
b = [i for i in range(10) if i>5]
print(a, len(a), b, len(b))     #[0, 2, 4, 6, 8] 5 [6, 7, 8, 9] 4

c = [i+5 for i in range(10) if i%3 == 0]    #[5, 8, 11, 14] 4
print(c, len(c))




#for반복문과 if조건문을 여러 번 사용하기

#구구단 만들기, 가독성을 위한 들여쓰기 syntax도 가능.... ㄷㄷ 

    #***아래 줄에서 갑자기 utf-8 encoding 에러가 발생하는 이유는...? (2)이렇게 <- 이쪽 부분을 붙여서 쓰면 인코딩 설정을 해주어야 하고, (2) 이렇게 <- 처럼 띄어쓰면 인코딩 설정이 필요가 없다... (??? 뭐냐이거 대체...)
    # for문이 여러 개인 경우 처리 순서는 뒤에서부터 앞으로. 즉, 나타나는 순서의 반대로 ... -> why ?? (1) 왜 이렇게 설계하였는가? 그냥 for문을 중첩하는 경우와 같이 앞에서부터 차례대로 실행하도록 하는 것이 더 자연스러운 것이 아닌지...? (2) 이렇게 뒤에서부터 실행하는 경우 실행 결과는 앞에서부터 해석하는 경우와 비교해서 어떤 차이가 있는가? 결과가 달라지는가 아니면 두 경우 모두 똑같은가? 

    # 1) -> 말을 헷갈렸는데, 일반적인 중첩 for문의 경우 안쪽 for문부터 처리한다. 즉, 뒤에서부터 처리하는 것이므로 list comprehension에서도 일반적인 중첩 for문의 처리 순서를 그대로 따르는 것임을 알 수 있다

    # 2) -> 결과의 차이는 없음. 해석해서 처리하는 순서만 뒤에서부터인 것으로 ...? (X) 
    # 2) -> 뒤에서부터 해석하므로 뒤쪽 변수를 중심으로 for문이 먼저 돌아간다고 생각해야 함. 즉 1)에서와 같이 일반적인 중첩 for문처럼 안쪽(뒤쪽) for문의 반복이 모두 종료된 후에 바깥쪽(앞쪽) for문의 반복이 돌아가는 것으로 생각한다  


# i=2...9, j=1...9 -> i를 2부터 고정한채로 i값을 1부터 10까지 돌리고... (이후 i값에 대해 반복)
a1 = [i*j for i in range(2, 10) for j in range(1, 10)]
# i=1...9, j=2...9 -> j를 2부터 고정한채로 i값을 1부터 10까지 돌리고... (이후 j값에 대해 반복)
a2 = [i*j for j in range(2, 10) 
            for i in range(1, 10)]

# i=2...4, j=1...4 -> i값을 고정하고 j값을 1부터 4까지 -> 구구단의 형태 (4개 숫자가 3묶음)
a3 = [i*j for i in range(2, 5) for j in range(1, 5)]
# i=1...4, j=2...4 -> i값을 고정하고 j값을 2부터 4까지 -> 구구단의 형태가 아님 (3개 숫자가 4묶음)
a4 = [i*j for i in range(1, 5) for j in range(2, 5)]

#2가지의 결과가 서로 같은 경우 
print(a1)
print(a2)   #[2, 4, 6, 8, 10, 12, 14, 16, 18, 3, 6, 9, 12, 15, 18, 21, 24, 27, 4, 8, 12, 16, 20, 24, 28, 32, 36, 5, 10, 15, 20, 25, 30, 35, 40, 45, 6, 12, 18, 24, 30, 36, 42, 48, 54, 7, 14, 21, 28, 35, 42, 49, 56, 63, 8, 16, 24, 32, 40, 48, 56, 64, 72, 9, 18, 27, 36, 45, 54, 63, 72, 81]

# 2가지의 결과가 서로 다른 경우
print(a3)   #[2, 4, 6, 8, // 3, 6, 9, 12, // 4, 8, 12, 16] 
print(a4)   #[2, 3, 4, // 4, 6, 8, // 6, 9, 12, // 8, 12, 16]



# 아래 결과를 보면 차이가 없다... 즉, commutative한 식에 대해서는 index의 위치와는 상관이 없는 것. 그냥 일반적인 중첩된 for문과 똑같이 동작한다고 보면 된다

b = [i*j for i in range(1, 4) for j in range(4, 7)]     #i=1...3, j=4...6
print(b)    #[4, 5, 6, 8, 10, 12, 12, 15, 18]
b = [i*j for j in range(1, 4) for i in range(4, 7)]     #i=4...6, j=1...3
print(b)    #[4, 5, 6, 8, 10, 12, 12, 15, 18]

b = [i+j for i in range(1, 4) for j in range(4, 7)]     #i=1...3, j=4...6
print(b)    #[5, 6, 7, 6, 7, 8, 7, 8, 9]
b = [i+j for j in range(1, 4) for i in range(4, 7)]     #i=4...6, j=1...3
print(b)    #[5, 6, 7, 6, 7, 8, 7, 8, 9]
